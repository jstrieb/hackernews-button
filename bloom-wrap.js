/* bloom-wrap.js
 *
 * Wrapper around Bloom filter WebAssembly functions. Includes a helper
 * function to take a normal URL and "canonicalize" it so that it matches the
 * format of the URLs inserted into the Bloom filter.
 *
 * Created by Jacob Strieb
 * January 2021
 */


/*******************************************************************************
 * Helper functions
 ******************************************************************************/

/***
 * Transform the current URL object to make it as "canonical" as possible. This
 * includes removing unnecessary URL parameters, removing "www." from the
 * beginning of URLs, stripping unnecessary parts of the path, and performing a
 * few domain-specific adjustments.
 *
 * NOTE: The order in which the transformations take place is subtly important.
 * Do not change the order around without good reason.
 *
 * NOTE: Any canonicalization changes made here *MUST* be reflected in the
 * `URL.canonicalize` function within the `canonicalize.py` file!
 */
function canonicalizeUrl(rawUrl) {
  let url = new URL(rawUrl);

  // Drop the fragment
  url.hash = "";

  // Remove unwanted URL parameters
  [
    "ref",
    "sms_ss",
    "gclid",
    "fbclid",
    "at_xt",
    "_r",
  ].forEach(p => url.searchParams.delete(p));
  Array.from(url.searchParams)
    .filter(p => p[0].startsWith("utm_"))
    .forEach(p => url.searchParams.delete(p[0]));

  // Truncate index.html, index.php, and trailing slashes
  if (url.pathname.endsWith("index.html")) {
    url.pathname = url.pathname.slice(0, -"index.html".length);
  }
  if (url.pathname.endsWith("index.php")) {
    url.pathname = url.pathname.slice(0, -"index.php".length);
  }
  if (url.pathname.endsWith("/")) {
    url.pathname = url.pathname.slice(0, -"/".length);
  }

  // Remove www.
  if (url.host.startsWith("www.")) {
    url.host = url.host.slice("www.".length,);
  }

  // Note: youtu.be URLs will auto-redirect to youtube.com, so we don't have to
  // check for the host being youtu.be
  if (url.host == "youtube.com") {
    if (url.searchParams.has("v")) {
      Array.from(url.searchParams)
        .filter(p => p[0] != "v")
        .forEach(p => url.searchParams.delete(p[0]));
    } else if (url.searchParams.has("list")) {
      Array.from(url.searchParams)
        .filter(p => p[0] != "list")
        .forEach(p => url.searchParams.delete(p[0]));
    }
  }

  // Drop all URL parameters on Amazon
  if (url.host == "amazon.com") {
    Array.from(url.searchParams)
      .forEach(p => url.searchParams.delete(p[0]));
  }

  // Change mobile Wikipedia links to regular ones
  if (url.host == "en.m.wikipedia.org") {
    url.host = "en.wikipedia.org";
  }

  // Drop the scheme
  let result = url.toString().replace(/^.*:\/\//, "//");

  return result;
}


/***
 * Delete the locally-stored Bloom filter. Useful for debugging from the
 * console.
 */
function deleteStoredBloom() {
  browser.storage.local.remove("bloom_filter");
  browser.storage.local.get().then(console.log);
}


/**
 * Save the Bloom filter to local storage
 */
function storeBloom(bloom) {
  bloom.filter = new Uint8Array(Module.HEAPU8.buffer, bloom.addr,
      Math.pow(2, bloom.num_bits - 3));
  browser.storage.local.set({"bloom_filter": bloom})
}



/*******************************************************************************
 * Wrapper functions
 ******************************************************************************/

function newBloom(bloom) {
  // Need to heap-allocate the bloom filter because passing it directly will
  // cause a stack overflow
  bloom.addr = Module.ccall(
    "js_new_bloom",
    "number",
    ["number"],
    [bloom.num_bits]
  );
  Module.writeArrayToMemory(bloom.filter, bloom.addr);
}


function freeBloom(bloom) {
  Module.ccall(
    "js_free_bloom",
    null,
    ["number"],
    [bloom.addr]
  );
}


/***
 * Decompress the compressed Bloom filter, and extract the address and size
 * from the struct generated by the library functions.
 */
function decompressBloom(bloom) {
  // Put the compressed Bloom filter on the heap
  let compressed = bloom.filter;
  let compressed_addr = _malloc(compressed.length);
  Module.writeArrayToMemory(compressed, compressed_addr);

  let decompressed = Module.ccall(
    "js_decompress_bloom",
    "number",
    ["number", "number"],
    [compressed_addr, compressed.length]
  );
  let size_bytes = Module.ccall(
    "js_get_decompressed_size",
    "number",
    ["number"],
    [decompressed]
  );
  if (size_bytes == 0) {
    throw "Failed to decompress downloaded Bloom filter!";
  }
  bloom.addr = Module.ccall(
    "js_get_decompressed_bloom",
    "number",
    ["number"],
    [decompressed]
  );
  bloom.num_bits = Math.round(Math.log2(size_bytes)) + 3,
  bloom.compressed = false;

  _free(compressed_addr);

  // Free the structure, but not the heap-allocated Bloom filter itself
  _free(decompressed);
}


function addBloom(bloom, url) {
  url = canonicalizeUrl(url);
  return Module.ccall(
    "js_add_bloom",
    null,
    ["number", "number", "string", "number"],
    [bloom.addr, bloom.num_bits, url, url.length]
  );
}


function inBloom(bloom, url) {
  url = canonicalizeUrl(url);
  return Module.ccall(
    "js_in_bloom",
    "boolean",
    ["number", "number", "string", "number"],
    [bloom.addr, bloom.num_bits, url, url.length]
  );
}



/*******************************************************************************
 * Main function
 ******************************************************************************/

/***
 * Load the Bloom filter as soon as there is a WebAssembly runtime to load it
 * with. This is typically right when the browser/extension starts up.
 */
async function load_bloom() {
  // Try to get the Bloom filter out of storage, otherwise download latest. To
  // clear the stored Bloom filter while testing, from the browser console do:
  // browser.storage.local.remove("bloom_filter")
  window.bloom = (await browser.storage.local.get("bloom_filter")).bloom_filter;
  if (!window.bloom || !window.bloom.filter) {
    console.debug("Fetching new Bloom filter...");
    let url = ("https://github.com/jstrieb/hackernews-button/releases/latest/"
              + "download/hn-0.bloom");
    let b = await fetch(url)
      .then(r => r.blob())
      .then(b => b.arrayBuffer())
      .then(a => new Uint8Array(a));
    window.bloom = {
      filter: b,
      // TODO: Get info about compression status from info.json
      compressed: true,
      num_bits: null,
      addr: null,
    };
    console.debug("Fetched: ", window.bloom);

    // Save the downloaded Bloom filter
    browser.storage.local.set({"bloom_filter": window.bloom})
  }

  // TODO: Fail gracefully if both attempts above to load a Bloom filter fail
  // console.error("Couldn't load Bloom filter from local storage or the web!");

  // Set bloom.addr
  if (window.bloom.compressed) {
    decompressBloom(window.bloom);
    storeBloom(window.bloom);
    console.debug("Decompressed: ", window.bloom);
  } else {
    newBloom(window.bloom);
  }

  // TODO: Is this enough? Or is this leaking memory?
  window.addEventListener("beforeunload", e => freeBloom(window.bloom.addr));
}

// NOTE: This works because this file is run before the autogenerated bloom.js
var Module = {
  onRuntimeInitialized: load_bloom,
};
